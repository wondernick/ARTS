## ARTS-Week9



### Algorithm

##### \322. Coin Change

给出一个零钱数组，一个总面值，要求通过零钱数组中值组合兑换出总面值，求用到零钱个数最少的方案，如果没有方案能够兑换总面值，则返回-1.

这道题是学习“覃超的算法课”中的一道动态规划题目，通过动态规划，可以组装出1~总面值的所有最优方案，再通过返回dp[amount]的值返回总面值为amount的最优方案，代码如下：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;
        for(int i = 0; i <= amount; ++i){
            for (auto n : coins){
                if(n <= i){
                    dp[i] = min(dp[i] , dp[i-n]+1);
                }
            }
        }
        
        return (dp[amount] > amount)? -1 : dp[amount];
    }
};



```

一般能够进行动态规划的题，都能够通过递归来解决，此题可以通过递归+记忆数组的方式得以解决。记忆数组的index是面值，value是最优解，DP可以认为是将条件维度内所有情况都算出，递归+记忆数组是将时间维度内的情况像树状一样打散，通过记忆化减少重复计算。剪枝代码非常重要，如果没有这一步会产生大量重复运算，造成TLE。代码如下：



```
int coinChange(vector<int>& coins, int amount) {
        vector<int> memo(amount+1,INT_MAX);
        memo[0] = 0;
        return change(coins,amount,memo);
    }

int change(vector<int>& coins,int target, vector<int>& memo){
    

    if(target<0){
        return -1;
    }
    
    if(memo[target]!=INT_MAX)
        return memo[target];
    
    for(auto n : coins){
        temp = change(coins,target-n,memo);
        if (temp>=0){
            memo[target] = min(memo[target],temp+1);
        }
    }
    
    memo[target] = (memo[target] == INT_MAX)?-1:memo[target];//剪枝
    
    return memo[target];

}
```

从Grandyang的博客中了解一种符合人类思考喜欢的代码，首先联想我们一般找零钱时的思维顺序：1.先看最大面额，如果最大面额能够被总面值整除，直接全部都用最大面额即可 2. 如果最大面额不能被整除，那就要看计算几张最大面额的合适，选取合适的最大面额张数后，总面值的余额用剩余的零钱面值按照同样的思路处理。 按照这个思想，我们先要把零钱数组排序，先取出最大的面值，同时我们需要传递一个当前已使用零钱张数 和 目前的最优解。 这种方案效率惊人，上面两种都是O(n2)的时间复杂度，这一种是O(n)的复杂度，效率非常高，代码如下：

```
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int res = INT_MAX,n = coins.size();
        sort(coins.begin(),coins.end());
        helper(coins,n-1,amount,0,res);
        return (res == INT_MAX)? -1:res;
    }
    void helper(vector<int>& coins, int start,int target, int cur , int &res) {
        if(start<0)
            return;

        if (target%coins[start] == 0){
            res = min(res,cur+target/coins[start]);
            return;
        }
        
        for(int i = target / coins[start]; i >= 0; --i){
            if(i+cur>=res-1) 
                return; //剪枝
            helper(coins,start-1,target - coins[start]*i, cur+i, res);
        }
    }

};
```

 

### Review

**硅谷产品实战36讲**

最近在驱动PM规划一个项目，本着了解PM工作流及核心产出的学习目的，买了《硅谷产品实战36讲》，目前已经学习了1/4，总结一下最近的学习收获。

#### 产品经理的要求

作者理解产品经理包含产品工程师和项目管理工程师的职责，**带领产品团队，在高效的时间里推出满足用户需求的产品** ，有一下四点具体职责：

1. **经人理事**，带领和鼓舞整个团队，要求产品经理具备管理能力、处理团队人际关系能力、统筹大家工作的能力、制定高效工作流程的能力
2. **理解用户需**求， 要求PM具备把用户需求转化为切实可行的产品功能，让用户体验更加通畅的能力
3. **能够高效执行**，既能够push团队又能够帮助团队解决执行中遇到的问题
4. **长远的眼光**，把控产品方向，制订各阶段产品成功标准

作为产品经理要避免**角色认知错误**，工程师、设计师不是PM的手下，**PM要具备通过个人影响带动团队的能力**，因为从行政角度来说，产品经理需要的影响他人，而不是直接管理他们。

作者介绍了她作为facebook产品经理的两天，其中一天工作内容主要为用户分析调研，理解用户和引导用户，联想到国内很多行业的PM，完全就是老板的传话筒和工头，既没有花心思分析用户，也没有创造条件去了解用户。另一天的工作内容主要为与工程师团队沟通，跟进项目推进，估计目标时间结点，删改功能点，保障项目交付。

#### 产品经理的工作内容

PM的工作内容取决于产品发布阶段：

1.**开发初期**，PM需要花大量时间在思考上。这个阶段主要弄清楚要做什么，所以需要花大量时间做调研，策划以及制定产品功能上。此时与工程师团队沟通比较少

2.**开发后半段**，PM需要花费大量时间在执行上。这段时间主要花时间解决开发难点，根据困难和挑战修改之前的方案。

PM涉及的会议：

1.**站会**，让工程师快速交流昨天完成和今天要做的事，及时发现开发的问题并马上解决。 思考：站会是否需要PM参加，我们公司的站会是由项目master 组织，PM全程是不参与的。 PM应该参加，很多技术问题可以通过产品手段解决，PM可以及时的了解进度和RD遇到的问题，及时响应

2.**部门周会**， 可以帮助年轻PM了解公司情况，学习老员工的经验和长处， 团队可以及时的了解高层的想法。

3.**优先级讨论会**，让大家讨论亟待开发的几个功能，砍掉优先级低的功能，权衡趋势，砍掉一些无关紧要的小功能，保障项目交付。

这是作者作为高阶PM对于PM的工作日常和会议分类的思考，我认为PM与RD开会一定要带着主题和方案，不要把会开成讨论会，脑暴会，效率低，还不一定能够解决问题。

#### 寻找用户需求

***用户需求一定要立足用户，一定要验证这个痛点到底是不是真的存在***

作者举了平衡车的例子，平衡车刚面世时，受到了市场和资本的极大欢迎，但这个被寄予厚望的发明却并没有顺利落地。平衡车需要经常充电，而且售价高。长途和通勤还是开车和公共交通方便，而短途用更便宜更方便的自行车是更多人的选择。平衡车解决的问题，并不是一个广大用户真正存在的痛点，这就是为什么发明了十几年后，最多的应用场景是孩子的家庭玩具。

如果强行的用新技术套用某个领域或者某个应用场景，而没有去验证用户是不是真正有这样的痛点；或者用户的痛点是不是足够大到让他们丢弃已有的习惯，使用一个新的产品，适应一个新的方式；或者这个产品加上人工智能之后，是不是可以真正解决一个以前解决不了的痛点。

**所以，一个好的PM一定能够先从痛点触发，确认用户是否真正存在这样一个问题**。

1.**确定好你的用户是谁**， 年龄段，职业属性，社会属性。

2.**通过数据分析和用户调查**，**作出关于用户痛点的假设**。

3.**进一步挖掘数据和用户反馈，验证用户痛点的存在。**

###### 如何做用户调研：

当你暂时只有一个大概的假设，知道用户的痛点大致在什么领域，但是并不清楚具体有哪些选择，需要非常系统地深入了解具体的痛点，这个时候和用户**一对一的面谈**效果最好。

面谈用户选择上需要注意这几点：

1.用户要具有代表性

2.要意识到面谈一对一的局限性。

如果你已经有一个比较成熟的假设，有几个选项，想知道用户怎么想。那么**问卷调查**会是更好的选择。

#### 目标用户和用户画像

弄清楚目标用户，是一个**先拓展再专注**的过程，先拓展就是要列出对产品有需求的所有人，并尽可能的细分。再专注就是要于最需要这个产品的人群，即使这个人群的规模很小，**切记能100%的解决一小部分人的需求，远胜于只解决一大群人50%的需求**。

这里需要注意，专注于小群体，并不会让你的产品丧失发展潜力。相反地，当你非常好的解决了一小部分人的需求后，他们会成为你的粉丝，自然而然的地自发地宣传这个产品，从而让其他用户也跃跃欲试。 比如Facebook一开始关注的是大学生，爱彼迎最开始关注的是沙发客，只有先解决好某一群人的需求，让你的产品成为解决这群人需求的最好方式，然后才能拓展到更多的人。

确定目标用户的过程中要切记两点：

1.对目标用户定位不够有针对性，人群选择出现偏差。

2.没有研究清楚目标群体最底层的需求是什么，或者说没有清楚地认识到产品到底要解决的底层需求是社么。 反思，有些有特殊的饭店，是解决人们餐食的问题吗？比如轻食素食的类的餐馆。

**描绘用户画像** 

用户画像对应的英文是 user story。意思是生动描绘用户的特点，把这些用户抽象成一个人，然后用介绍这个人的方式来描绘这一类人。

借用评论区一位高赞评论：

用户画像就是先对用户做聚类分析，明确有哪些类型的人群，画像则是对人群的人格化，这样方便理解、讲故事。

极客时间的宗旨是提高技术认知，用户基本定位是职场人士，有一定技术背景或从事相关行业，能有效利用业务时间提升自己，且希望快速找到他人成功方法并加以实践的人群。



### TIp

Flask搭建http服务

通过pykafka 构建kafka 生产者



#### Share

https://medium.com/better-programming/rabbitmq-vs-kafka-1ef22a041793

MQ和kafka的区别：

1. MQ是基于队列和交换，kafka的存储层是通过一个分块的传输日志实现。kafka同时提供了处理数据流的接口，实时的处理流数据和多重源数据的集成。
2. 有些场景下，MQ和kafka是可以互换了。但两者还有有实现方式上的区别。
3. MQ的吞吐量略逊于kafka

4. MQ的负载均衡需要单独的loadbalancer支持，kafka是用到 zookeeper。